{"version":3,"sources":["../src/aggregate-root.js"],"names":[],"mappings":";;;;;;;;AAAA;;;;AAEA,IAAM,4BAA4B,kDAAlC;AACA,IAAM,0BAAyB,SAAzB,uBAAyB;AAAA,SAAO;AACpC,UAAM;AAD8B,GAAP;AAAA,CAA/B;;AAIA,IAAM,uBAAuB,SAAvB,oBAAuB,GAAuB;AAAA,MAAtB,KAAsB,yDAAd,EAAc;AAAA,MAAV,KAAU;;AAClD,MAAI,MAAM,IAAN,KAAe,cAAnB,EACE,OAAO,EAAP;;AAEF,MAAI,MAAM,IAAN,KAAe,yBAAnB,EACE,OAAO,EAAP;;AAEF,SAAO,MAAM,MAAN,CAAa,KAAb,CAAP;AACD,CARD;;IAUqB,a;AACnB;;;;;;;;;;;;;;;AAeA,yBAAY,MAAZ,EAAoB,kBAApB,EAAwC,YAAxC,EAAsD;AAAA;;AACpD,QAAM,WAAW,OAAO,MAAP,CACf,UAAC,KAAD,EAAO,KAAP;AAAA,aAAiB,mBAAmB,KAAnB,EAAyB,KAAzB,CAAjB;AAAA,KADe,EAEf,YAFe,CAAjB;;AAIA,QAAM,WAAW;AACf,mBAAa,kBADE;AAEf,qBAAe,oBAFA,EAAjB;AAGA,SAAK,KAAL,GAAa,wBAAY,4BAAgB,QAAhB,CAAZ,EAAuC;AAClD,mBAAa;AADqC,KAAvC,CAAb;AAGD;;AAED;;;;;;;;;AAOA;;;;;;;;;;;;;gCAaY,K,EAAO;AACjB,WAAK,KAAL,CAAW,QAAX,CAAoB,KAApB;AACD;;AAED;;;;;;;;;;;;;4CAUwB;AACtB,aAAO,KAAK,KAAL,CAAW,QAAX,GAAsB,aAA7B;AACD;;AAED;;;;;;;;;;;6CAQyB;AACvB,WAAK,KAAL,CAAW,QAAX,CAAoB,yBAApB;AACD;;;wBA7CW;AACV,aAAO,KAAK,KAAL,CAAW,QAAX,GAAsB,WAA7B;AACD;;;;;;kBAlCkB,a","file":"aggregate-root.js","sourcesContent":["import { createStore, combineReducers } from \"redux\";\n\nconst MARK_CHANGES_AS_COMMITTED = \"@@cqrs-redux-js/events/MARK_CHANGES_AS_COMMITTED\";\nconst markChangesAsCommitted = () => ({\n  type: MARK_CHANGES_AS_COMMITTED\n})\n\nconst entityChangesReducer = (state = [], event) => {\n  if( event.type === '@@redux/INIT' )\n    return [];\n\n  if( event.type === MARK_CHANGES_AS_COMMITTED )\n    return [];\n\n  return state.concat(event);\n}\n\nexport default class AggregateRoot {\n  /**\n   * @param {array} events\n   * @param {function} entityStateReducer\n   * @param {function} initialState\n   * @example <caption>Create Subclass</caption>\n   * const initialState = {};\n   * const reducer = (state, event) => {\n   *\n   * };\n   * class DomainEntity extends AggregateRoot {\n   *  constructor(events, props) {\n   *    super(events, reducer, initialState);\n   *  }\n   * }\n   */\n  constructor(events, entityStateReducer, initialState) {\n    const appState = events.reduce(\n      (state,event) => entityStateReducer(state,event),\n      initialState);\n\n    const reducers = {\n      entityState: entityStateReducer,\n      entityChanges: entityChangesReducer };\n    this.store = createStore(combineReducers(reducers), {\n      entityState: appState\n    });\n  }\n\n  /**\n   * @return {object}\n   */\n  get state() {\n    return this.store.getState().entityState;\n  }\n\n  /**\n   * We need a means of recording changes that happen to an aggregate\n   * root.\n   *\n   * @param {object} event a domain event that you would like to save\n   *\n   * @example <caption>Add Domain Event to Entity Changes</caption>\n   * this.applyChange({\n   *   aggregateId: \"\",\n   *   version: 1,\n   *   type: ACCOUNT_CREATED\n   * })\n   */\n  applyChange(event) {\n    this.store.dispatch(event);\n  }\n\n  /**\n   * Clients need a means of retrieving the changes that have happened\n   * to an aggregate root.\n   *\n   * @return {array}\n   *\n   * @example <caption>Publish Domain Events</caption>\n   * publisher.publish(entity.getUncommittedChanges())\n   *\n   */\n  getUncommittedChanges() {\n    return this.store.getState().entityChanges;\n  }\n\n  /**\n   * An aggregate root needs to let clients clear all its domain events\n   * once they have processed the domain events.\n   *\n   * @example <caption>Clear Domain Events After Publishing</caption>\n   * publisher.publish(entity.getUncommittedChanges());\n   * entity.markChangesAsCommitted();\n   */\n  markChangesAsCommitted() {\n    this.store.dispatch(markChangesAsCommitted());\n  }\n}\n"]}